(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.2'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[     19235,        371]*)
(*NotebookOutlinePosition[     19920,        395]*)
(*  CellTagsIndexPosition[     19876,        391]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell[BoxData[{
    \(\(TrunkPath\  = \ "\<C:/drorbn/projects/KnotTheory/svn/trunk\>";\)\), "\
\[IndentingNewLine]", 
    \(\(AppendTo[$Path, \ TrunkPath];\)\), "\[IndentingNewLine]", 
    \(<< \ KnotTheory`\)}], "Input"],

Cell[BoxData[
    \("Loading KnotTheory` version of July 31, 2006, 9:34:35.6875.\nRead more \
at http://katlas.math.toronto.edu/wiki/KnotTheory."\)], "Print"]
}, Open  ]],

Cell[BoxData[{
    \(\(InterlacedQ[{a_, b_}, \ {c_, 
            d_}]\  := \ \((Signature[{a, b}] Signature[{c, d}] 
              Signature[{a, b, c, 
                  d}] === \(-1\))\);\)\), "\[IndentingNewLine]", 
    \(\(PlanarGridDiagram[ml_MorseLink]\  := \ 
        Module[\[IndentingNewLine]{ActiveVerts, \ VertOrdering, \ vc, out, m, 
            n, k, p, b, c, br, bl, r, \ l, \ UnneededVerts, \ 
            PGD}, \[IndentingNewLine]ActiveVerts = {}; \ VertOrdering = {}; \ 
          vc = 0; \[IndentingNewLine]out\  = \ \(\((List\  @@ \ 
                    ml)\)\  /. \ {\[IndentingNewLine]Cup[m_, 
                      n_]\  \[RuleDelayed] \ \((\[IndentingNewLine]k\  = \ 
                        Min[m, n]; \[IndentingNewLine]ActiveVerts\  = \ 
                        Insert[ActiveVerts, \ \(++vc\), \ 
                          k]; \[IndentingNewLine]ActiveVerts\  = \ 
                        Insert[ActiveVerts, \ \(++vc\), \ 
                          k + 1]; \[IndentingNewLine]If[
                        k \[Equal] 
                          1, \[IndentingNewLine]VertOrdering = {vc - 1, \ vc}~
                            Join~VertOrdering, \[IndentingNewLine]{{p}}\  = \ 
                          Position[VertOrdering, \ 
                            ActiveVerts[\([k - 
                                  1]\)]]; \[IndentingNewLine]VertOrdering\  = \
\ Insert[VertOrdering, \ vc - 1, \ 
                            p + 1]; \[IndentingNewLine]VertOrdering\  = \ 
                          Insert[VertOrdering, \ \ vc, \ 
                            p + 2];\[IndentingNewLine]]; \
\[IndentingNewLine]{m, n} - k + vc - 
                        1\ \[IndentingNewLine])\), \[IndentingNewLine]X[n_, \ 
                      Under, \ b_, \ 
                      c_]\  \[RuleDelayed] \ \ \((\[IndentingNewLine]bl = 
                        ActiveVerts[\([n]\)]; \[IndentingNewLine]ActiveVerts\ \
 = \ Insert[Delete[ActiveVerts, \ \ n], \ \(++vc\), \ 
                          n + 1]; \[IndentingNewLine]{{p}}\  = \ 
                        Position[VertOrdering, \ 
                          ActiveVerts[\([n]\)]]; \
\[IndentingNewLine]VertOrdering\  = \ 
                        Insert[VertOrdering, \ \ vc, \ 
                          p + 1]; \[IndentingNewLine]If[
                        b === Up, \ {bl, \ vc}, \ {vc, 
                          bl}]\[IndentingNewLine])\), \[IndentingNewLine]X[
                      n_, \ Over, \ b_, \ 
                      c_]\  \[RuleDelayed] \ \ \((\[IndentingNewLine]br = 
                        ActiveVerts[\([n + 
                              1]\)]; \[IndentingNewLine]ActiveVerts\  = \ 
                        Insert[Delete[ActiveVerts, \ \ n + 1], \ \(++vc\), \ 
                          n]; \[IndentingNewLine]{{p}}\  = \ 
                        Position[VertOrdering, \ 
                          ActiveVerts[\([n + 
                                1]\)]]; \[IndentingNewLine]VertOrdering\  = \ 
                        Insert[VertOrdering, \ \ vc, \ 
                          p]; \[IndentingNewLine]If[
                        c === Up, \ {br, \ vc}, \ {vc, 
                          br}]\[IndentingNewLine])\), \[IndentingNewLine]Cap[
                      m_, \ n_]\  \[RuleDelayed] \ \((\[IndentingNewLine]r = \
{ActiveVerts[\([m]\)], \ 
                          ActiveVerts[\([n]\)]}; \
\[IndentingNewLine]ActiveVerts\  = \ 
                        Delete[
                          ActiveVerts, \ {{m}, \ {n}}]; \[IndentingNewLine]r\
\[IndentingNewLine])\)\[IndentingNewLine]}\)\  /. \ 
              Thread[Rule[VertOrdering, \ 
                  Range[Length[
                      VertOrdering]]]]; \[IndentingNewLine]UnneededVerts = \
{}; \[IndentingNewLine]out\  = \ \((PGD\  @@ \ 
                  out)\)\  //. \ {\[IndentingNewLine]PGD[
                      l___, \ {a_, \ b_}, \ m___, \ {b_, c_}, \ 
                      r___]\  /; \ \((a \[NotEqual] 
                          c\  && \ \(! \((Or\  @@ \ \((\(InterlacedQ[{a, 
                                        b}, \ #] &\)\  /@ \ {m})\))\)\))\)\  \
\[RuleDelayed] \ \((\[IndentingNewLine]AppendTo[UnneededVerts, \ 
                      b]; \[IndentingNewLine]PGD[l, \ m, \ {a, c}, \ 
                      r]\[IndentingNewLine])\), \[IndentingNewLine]PGD[
                      l___, \ {b_, \ a_}, \ m___, \ {c_, b_}, \ 
                      r___]\  /; \ \((a \[NotEqual] 
                          c\  && \ \(! \((Or\  @@ \ \((\(InterlacedQ[{a, 
                                        b}, \ #] &\)\  /@ \ {m})\))\)\))\)\  \
\[RuleDelayed] \ \((\[IndentingNewLine]AppendTo[UnneededVerts, \ 
                      b]; \[IndentingNewLine]PGD[l, \ m, \ {c, \ a}, \ 
                      r]\[IndentingNewLine])\), \[IndentingNewLine]PGD[
                      l___, \ {b_, \ c_}, \ m___, \ {a_, b_}, \ 
                      r___]\  /; \ \((a \[NotEqual] 
                          c\  && \ \(! \((Or\  @@ \ \((\(InterlacedQ[{a, 
                                        b}, \ #] &\)\  /@ \ {m})\))\)\))\)\  \
\[RuleDelayed] \ \((\[IndentingNewLine]AppendTo[UnneededVerts, \ 
                      b]; \[IndentingNewLine]PGD[l, \ \ {a, c}, \ m, \ 
                      r]\[IndentingNewLine])\), \[IndentingNewLine]PGD[
                      l___, \ {c_, \ b_}, \ m___, \ {b_, a_}, \ 
                      r___]\  /; \ \((a \[NotEqual] 
                          c\  && \ \(! \((Or\  @@ \ \((\(InterlacedQ[{a, 
                                        b}, \ #] &\)\  /@ \ {m})\))\)\))\)\  \
\[RuleDelayed] \ \((\[IndentingNewLine]AppendTo[UnneededVerts, \ 
                      b]; \[IndentingNewLine]PGD[l, \ \ {c, \ a}, \ m, \ 
                      r]\[IndentingNewLine])\)\[IndentingNewLine]}; \
\[IndentingNewLine]out\  = \ 
            out\  /. \ Thread[
                Rule[Delete[Range[vc], \ List\  /@ \ UnneededVerts], \ 
                  Range[vc - 
                      Length[UnneededVerts]]]]; \
\[IndentingNewLine]PlanarGridDiagram\  @@ \ 
            out\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(PlanarGridDiagram[K_]\  := \ 
        PlanarGridDiagram[
          MorseLink[K]];\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(\(Options[
          Draw]\  = \ {OverlayMatrix\  \[Rule] \ 
            Null};\)\), "\[IndentingNewLine]", 
    \(Draw[pgd_PlanarGridDiagram, \ opts___Rule]\ \  := \ 
      Module[\[IndentingNewLine]{\[IndentingNewLine]l, p1, p2, k, \ 
          V, \[IndentingNewLine]om\  = \ \(OverlayMatrix\  /. \ {opts}\)\  \
/. \ Options[Draw]\[IndentingNewLine]}, \[IndentingNewLine]l\  = \ 
          Length[pgd]; \[IndentingNewLine]Graphics[
          Flatten[{\[IndentingNewLine]{Thickness[\(1/10\)/
                    Length[pgd]]}, \[IndentingNewLine]Table[\
\[IndentingNewLine]Line[{{pgd[\([k, \ 1]\)], \ k}, \ {pgd[\([k, 2]\)], \ 
                      k}}], \[IndentingNewLine]{k, 
                  l}\[IndentingNewLine]], \[IndentingNewLine]{Thickness[
                  0.45/Length[pgd]], \ 
                GrayLevel[
                  1]}, \[IndentingNewLine]Table[\[IndentingNewLine]{{p1}}\  = \
\ Position[First\  /@ \ pgd, \ k]; \[IndentingNewLine]{{p2}}\  = \ 
                  Position[Last\  /@ \ pgd, \ k]; \[IndentingNewLine]{p1, \ 
                    p2}\  = \ 
                  Sort[{p1, p2}]; \[IndentingNewLine]Line[{{k, \ 
                      p1 + 0.5}, \ {k, \ 
                      p2 - 0.5}}], \[IndentingNewLine]{k, \ 
                  l}\[IndentingNewLine]], \[IndentingNewLine]{Thickness[\(1/
                      10\)/Length[pgd]], \ 
                GrayLevel[
                  0]}, \[IndentingNewLine]Table[\[IndentingNewLine]{{p1}}\  = \
\ Position[First\  /@ \ pgd, \ k]; \[IndentingNewLine]{{p2}}\  = \ 
                  Position[Last\  /@ \ pgd, \ 
                    k]; \[IndentingNewLine]Line[{{k, \ p1}, \ {k, \ 
                      p2}}], \[IndentingNewLine]{k, \ 
                  l}\[IndentingNewLine]], \[IndentingNewLine]If[
                om === Null, \ {}, \[IndentingNewLine]MapIndexed[\
\[IndentingNewLine]Text[#1, \ 0.5 + #2] &, \[IndentingNewLine]Transpose[
                    om], \ {2}\[IndentingNewLine]]\[IndentingNewLine]]\
\[IndentingNewLine]}]]\[IndentingNewLine]]\[IndentingNewLine]\), "\
\[IndentingNewLine]", 
    \(\(MinesweeperMatrix[pgd_PlanarGridDiagram]\  := \ 
        Module[\[IndentingNewLine]{l, \ CurrentRow, \ c1, c2, k, 
            s}, \[IndentingNewLine]l = 
            Length[pgd]; \[IndentingNewLine]CurrentRow\  = \ 
            Table[0, \ {l}]; \[IndentingNewLine]Table[\[IndentingNewLine]{c1, \
\ c2}\  = \ Sort[pgd[\([k]\)]]; \[IndentingNewLine]s = 
              Sign[{\(-1\), 1} . 
                  pgd[\([k]\)]]; \
\[IndentingNewLine]Do[\[IndentingNewLine]CurrentRow[\([c]\)] += 
                s, \[IndentingNewLine]{c, \ c1, \ 
                c2 - 1}\[IndentingNewLine]]; \[IndentingNewLine]CurrentRow, \
\[IndentingNewLine]{k, 
              l}\[IndentingNewLine]]\[IndentingNewLine]];\)\), "\
\[IndentingNewLine]", 
    \(\(MinesweeperMatrix[K_]\  := \ 
        MinesweeperMatrix[
          PlanarGridDiagram[
            K]];\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(NeuwirthMatrix[pgd_PlanarGridDiagram]\  := \ 
      Module[\[IndentingNewLine]{l, \ mm, t}, \[IndentingNewLine]l = 
          Length[pgd]; \[IndentingNewLine]Function\  @@ \ \
{\[IndentingNewLine]mm = 
              t^MinesweeperMatrix[pgd]; \[IndentingNewLine]ReplacePart[
                Factor[\((mm - RotateLeft[mm])\)/\((t - 1)\)], \ First[mm], \ 
                1]\  /. \ 
              t\  \[Rule] \ #\[IndentingNewLine]}\[IndentingNewLine]]\)}], \
"Input"],

Cell[BoxData[{
    \(\(Clear[\[IndentingNewLine]pgd, \ n, \ MM, \ a, \ PP, \ WW, \ 
        AlexanderDegreeShift, \ AlexanderDegree, \ x0, \ MaslovDegree, \ 
        Boundary, \ AllStates, \ BoundaryMatrix, \ Rank, \ Betti, \ 
        MOSHomology\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(pgd\  = \ 
        PlanarGridDiagram[TorusKnot[4, 3]];\)\), "\[IndentingNewLine]", 
    \(\(n = 
        Length[MM\  = \ MinesweeperMatrix[pgd]];\)\), "\[IndentingNewLine]", 
    \(\(a[p1_, \ 
          p2_]\  := \ \(a[p1, \ 
            p2]\  = \ \(-MM[\([p1\  /. \ 0\  \[Rule] \ n, \ 
                p2\  /. \ 0\  \[Rule] \ 
                    n]\)]\)\);\)\), "\[IndentingNewLine]", 
    \(\(AlexanderDegreeShift\  = \ \((1 - n)\)/2\  - \ 
          1/8*Sum[\[IndentingNewLine]a[k, \ pgd[\([k, \ 1]\)]]\  + \ 
                a[k, \ pgd[\([k, \ 1]\)] - 1]\  + \ 
                a[k - 1, \ pgd[\([k, \ 1]\)]]\  + \ 
                a[k - 1, \ pgd[\([k, \ 1]\)] - 1]\[IndentingNewLine] + \ 
                a[k, \ pgd[\([k, \ 2]\)]]\  + \ 
                a[k, \ pgd[\([k, \ 2]\)] - 1]\  + \ 
                a[k - 1, \ pgd[\([k, \ 2]\)]]\  + \ 
                a[k - 1, \ pgd[\([k, \ 2]\)] - 1], \[IndentingNewLine]{k, 
                n}\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(AlexanderDegree[x_State]\  := \ \(AlexanderDegree[x]\  = \ 
          AlexanderDegreeShift\  + \ 
            Sum[\[IndentingNewLine]a[k, \ 
                x[\([k]\)]], \[IndentingNewLine]{k, \ 
                n}\[IndentingNewLine]]\);\)\), "\[IndentingNewLine]", 
    \(\(x0 = 
        State\  @@ \ 
            RotateLeft[\(-1\) + First\  /@ \ \(List\  @@ \ pgd\)]\  /. \ 
          0\  \[Rule] \ n;\)\), "\[IndentingNewLine]", 
    \(\(MaslovDegree[x0]\  = \ 1 - n;\)\), "\[IndentingNewLine]", 
    \(\(WW[{{i1_, \ i2_}, \ {j1_, \ 
              j2_}}]\  := \ \(WW[{{i1, i2}, \ {j1, j2}}]\  = \ 
          Length[Select[\[IndentingNewLine]First\  /@ \ \((List\  @@ \ 
                      pgd)\)[\([Range[i1 + 1, \ 
                      i2]]\)], \[IndentingNewLine]\((j1 < # \[LessEqual] 
                    j2)\) &\[IndentingNewLine]]]\);\)\), \
"\[IndentingNewLine]", 
    \(\(PP[s_State, \ {{i1_, \ i2_}, \ {j1_, \ j2_}}]\  := \ 
        Module[\[IndentingNewLine]{k, 
            l}, \[IndentingNewLine]Sum[\[IndentingNewLine]l = 
              s[\([k]\)]; \[IndentingNewLine]If[i1 < k < i2, \ 1, \ 1/2]*
              Which[\[IndentingNewLine]j1 < l < j2, \ 
                1, \[IndentingNewLine]j1 \[Equal] l\  || \ j2 \[Equal] l, \ 
                1/2, \[IndentingNewLine]True, \ 
                0\[IndentingNewLine]], \[IndentingNewLine]{k, i1, 
              i2}\[IndentingNewLine]]\[IndentingNewLine]];\)\), "\
\[IndentingNewLine]", 
    \(\(MaslovDegree[x_State]\  := \ \(MaslovDegree[x]\ \  = \ 
          Module[\[IndentingNewLine]{i1, \ i2, \ j1, \ j2, \ y, \ r, \ 
              s}, \[IndentingNewLine]i1\  = \ 1; \ 
            While[x[\([i1]\)]\  \[Equal] \ 
                x0[\([i1]\)], \ \(++i1\)]; \[IndentingNewLine]j1\  = \ 
              x[\([i1]\)]; \ 
            j2\  = \ x0[\([i1]\)]; \[IndentingNewLine]{{i2}}\  = \ 
              Position[x, \ 
                j2]; \[IndentingNewLine]r\  = \ {Sort[{i1, i2}], \ 
                Sort[{j1, j2}]}; \[IndentingNewLine]s\  = \ 
              Sign[i2 - i1]*Sign[j2 - j1]; \[IndentingNewLine]y = x; \ 
            y[\([i1]\)] = j2; \ 
            y[\([i2]\)] = j1; \[IndentingNewLine]MaslovDegree[y]\  + \ 
              s \((PP[x, \ r]\  + \ PP[y, \ r]\  - \ 
                    2  WW[r])\)\[IndentingNewLine]]\);\)\), "\
\[IndentingNewLine]", 
    \(\(Boundary[x_State]\  := \ \(Boundary[x]\  = \ 
          Module[\[IndentingNewLine]{i1, i2, \ j1, \ j2, \ i, \ cyci, \ 
              cycj}, \[IndentingNewLine]Sum[\[IndentingNewLine]j1\  = \ 
                x[\([i1]\)]; \ 
              j2\  = \ x[\([i2]\)]; \[IndentingNewLine]y = x; \ 
              y[\([i1]\)] = j2; \ 
              y[\([i2]\)] = 
                j1; \[IndentingNewLine]Sum[\[IndentingNewLine]i = 
                  1; \[IndentingNewLine]While[\[IndentingNewLine]1 \
\[LessEqual] i \[LessEqual] 
                    n, \[IndentingNewLine]cyci\  = \ \((\((s \[Equal] 
                            Signature[{i1, \ #, \ 
                                i2}])\) &)\); \[IndentingNewLine]cycj\  = \ \
\((\((s \[Equal] Signature[{j1, \ #, \ 
                                j2}])\) &)\); \[IndentingNewLine]If[\
\[IndentingNewLine]Or[\[IndentingNewLine]cyci[i]\  && \ 
                        cycj[x[\([i]\)]], \[IndentingNewLine]cyci[
                          i - 1/2]\ \  && \ \((cycj[
                              pgd[\([i, 1]\)] - 1/2]\  || \ 
                            cycj[pgd[\([i, 2]\)] - 
                                1/2])\)\[IndentingNewLine]], \
\[IndentingNewLine]i = 
                      0, \ \(++i\)\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]If[i > n, \ y, \ 0], \[IndentingNewLine]{s, \ \(-1\), \ 
                  1, \ 2}\[IndentingNewLine]], \[IndentingNewLine]{i1, \ 1, \ 
                n - 1}, \[IndentingNewLine]{i2, \ i1 + 1, \ 
                n}\[IndentingNewLine]]\[IndentingNewLine]]\);\)\), "\
\[IndentingNewLine]", 
    \(\(Boundary[expr_]\  := \ 
        expr\  /. \ x_State\  \[RuleDelayed] \ 
            Boundary[x];\)\), "\[IndentingNewLine]", 
    \(\(AllStates[]\  = \ \(\((State\  @@ \ #)\) &\)\  /@ \ 
          Permutations[Range[n]];\)\), "\[IndentingNewLine]", 
    \(\(AllStates[m_, \ a_]\  := \ 
        Select[AllStates[], \ \((MaslovDegree[#] \[Equal] m\  && \ 
                AlexanderDegree[#] \[Equal] 
                  a)\) &];\)\), "\[IndentingNewLine]", 
    \(\(BoundaryMatrix[m_, \ a_]\  := \ 
        Outer[\[IndentingNewLine]\((\(Boundary[#2]\  /. \ #1\  \[Rule] \ 
                    1\)\  /. \ _State\  \[Rule] \ 
                  0)\) &, \[IndentingNewLine]AllStates[m - 1, \ a], \ 
          AllStates[m, \ a]\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(Rank[m_, \ a_] := \ \(Rank[m, a]\  = \ 
          If[\[IndentingNewLine]\ 
            AllStates[m, \ a] === {}\  || \ 
              AllStates[m - 1, \ 
                  a] === {}\ , \[IndentingNewLine]0, \
\[IndentingNewLine]MatrixRank[BoundaryMatrix[m, \ a], \ 
              Modulus\  \[Rule] \ 
                2]\[IndentingNewLine]]\);\)\), "\[IndentingNewLine]", 
    \(\(Betti[m_, \ a_]\  := \ 
        Length[AllStates[m, a]] - Rank[m, a] - 
          Rank[m + 1, \ a];\)\), "\[IndentingNewLine]", 
    \(\(MOSHomology[]\  := \ 
        Outer[\[IndentingNewLine]Betti, \[IndentingNewLine]Union[
            MaslovDegree\  /@ \ AllStates[]], \[IndentingNewLine]Union[
            AlexanderDegree\  /@ \ 
              AllStates[]]\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(MOSPoincare[]\  := \ 
        Expand[Factor[\[IndentingNewLine]Total[
                Flatten[
                  Outer[\[IndentingNewLine]\((m^#1\ t^#2\ Betti[#1, \ #2])\) \
&, \[IndentingNewLine]Union[
                      MaslovDegree\  /@ \ 
                        AllStates[]], \[IndentingNewLine]Union[
                      AlexanderDegree\  /@ \ 
                        AllStates[]]\[IndentingNewLine]]]]\ /\ \((1 + 
                    1/\((t\ m)\))\)^\((n - 
                    1)\)\[IndentingNewLine]]];\)\)}], "Input"],

Cell[BoxData[""], "Input"]
},
FrontEndVersion->"5.2 for Microsoft Windows",
ScreenRectangle->{{0, 1600}, {0, 1102}},
WindowSize->{801, 1012},
WindowMargins->{{22, Automatic}, {Automatic, 7}},
ShowSelection->True,
Magnification->1
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 220, 4, 70, "Input"],
Cell[1999, 59, 158, 2, 44, "Print"]
}, Open  ]],
Cell[2172, 64, 9672, 166, 2690, "Input"],
Cell[11847, 232, 7355, 135, 1910, "Input"],
Cell[19205, 369, 26, 0, 30, "Input"]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

